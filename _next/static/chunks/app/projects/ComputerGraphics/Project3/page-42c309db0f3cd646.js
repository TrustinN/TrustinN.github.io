(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[409],{5081:(e,t,n)=>{Promise.resolve().then(n.bind(n,5624))},9730:(e,t,n)=>{"use strict";n.d(t,{A:()=>l});var i=n(2115),r=n(2784),o=function(){return(o=Object.assign||function(e){for(var t,n=1,i=arguments.length;n<i;n++)for(var r in t=arguments[n])Object.prototype.hasOwnProperty.call(t,r)&&(e[r]=t[r]);return e}).apply(this,arguments)},a=function(e,t){var n={};for(r in e)Object.prototype.hasOwnProperty.call(e,r)&&0>t.indexOf(r)&&(n[r]=e[r]);if(null!=e&&"function"==typeof Object.getOwnPropertySymbols)for(var i=0,r=Object.getOwnPropertySymbols(e);i<r.length;i++)0>t.indexOf(r[i])&&Object.prototype.propertyIsEnumerable.call(e,r[i])&&(n[r[i]]=e[r[i]]);return n},s=function(e){return"Typesetting failed: ".concat(void 0!==e.message?e.message:JSON.stringify(e))};let l=function(e){function t(){var e;"every"===b&&A&&"post"===j&&null!==v.current&&(v.current.style.visibility=null!=(e=null==(e=g.style)?void 0:e.visibility)?e:"visible"),C.current||("first"===b&&null!==v.current&&(v.current.style.visibility="visible"),c&&c(),C.current=!0),h&&h(),_.current=!1}var n=e.inline,l=void 0!==n&&n,n=e.hideUntilTypeset,c=e.onInitTypeset,h=e.onTypeset,d=e.text,u=e.dynamic,f=e.typesettingOptions,m=e.renderMode,p=e.children,g=a(e,["inline","hideUntilTypeset","onInitTypeset","onTypeset","text","dynamic","typesettingOptions","renderMode","children"]),x=(0,i.useRef)(""),v=(0,i.useRef)(null),w=(0,i.useContext)(r.k),b=null!=n?n:null==w?void 0:w.hideUntilTypeset,j=null!=m?m:null==w?void 0:w.renderMode,y=null!=f?f:null==w?void 0:w.typesettingOptions,A=!1!==u&&(u||!1),C=(0,i.useRef)(!1),_=(0,i.useRef)(!1);return!_.current&&null!==v.current&&A&&"every"===b&&"post"===j&&(v.current.style.visibility="hidden"),("undefined"!=typeof window?i.useLayoutEffect:i.useEffect)(function(){if((A||!C.current)&&null!==v.current){if(!w)throw Error("MathJax was not loaded, did you use the MathJax component outside of a MathJaxContext?");if("pre"===j){if(!("string"==typeof d&&0<d.length))throw Error("Render mode 'pre' requires text prop to be set and non-empty, which was currently \"".concat(d,'"'));if(!f||!f.fn)throw Error("Render mode 'pre' requires 'typesettingOptions' prop with 'fn' property to be set on MathJax element or in the MathJaxContext");if(2===w.version)throw Error("Render mode 'pre' only available with MathJax 3, and version 2 is currently in use")}"post"!==j&&d===x.current||_.current||(_.current=!0,3===w.version?w.promise.then(function(e){var n;"pre"===j?(n=function(n){x.current=d,e.startup.document.clear(),e.startup.document.updateDocument(),null!==v.current&&(v.current.innerHTML=n.outerHTML),t()},f.fn.endsWith("Promise")?e.startup.promise.then(function(){return e[y.fn](d,o(o({},(null==y?void 0:y.options)||{}),{display:!l}))}).then(n).catch(function(e){throw t(),Error(s(e))}):e.startup.promise.then(function(){n(e[y.fn](d,o(o({},(null==y?void 0:y.options)||{}),{display:!l})))}).catch(function(e){throw t(),Error(s(e))})):e.startup.promise.then(function(){return e.typesetClear([v.current]),e.typesetPromise([v.current])}).then(t).catch(function(e){throw t(),Error(s(e))})}).catch(function(e){throw t(),Error(s(e))}):w.promise.then(function(e){e.Hub.Queue(["Typeset",e.Hub,v.current]),e.Hub.Queue(t)}).catch(function(e){throw t(),Error(s(e))}))}}),i.createElement("span",o({},g,{style:o(o({display:l?"inline":"block"},g.style),{visibility:b?"hidden":null==(e=g.style)?void 0:e.visibility}),ref:v}),p)}},2784:(e,t,n)=>{"use strict";n.d(t,{A:()=>h,k:()=>s});var i,r,o=n(2115),a=function(){return(a=Object.assign||function(e){for(var t,n=1,i=arguments.length;n<i;n++)for(var r in t=arguments[n])Object.prototype.hasOwnProperty.call(t,r)&&(e[r]=t[r]);return e}).apply(this,arguments)},s=(0,o.createContext)(void 0),l="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.9/MathJax.js?config=TeX-MML-AM_CHTML",c="https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js";let h=function(e){var t=e.config,n=e.version,n=void 0===n?3:n,h=e.src,h=void 0===h?2===n?l:c:h,d=e.onStartup,u=e.onLoad,f=e.asyncLoad,m=void 0!==f&&f,p=e.onError,f=e.typesettingOptions,g=e.renderMode,g=void 0===g?"post":g,x=e.hideUntilTypeset,e=e.children,v=(0,o.useContext)(s);if(void 0!==(null==v?void 0:v.version)&&(null==v?void 0:v.version)!==n)throw Error("Cannot nest MathJaxContexts with different versions. MathJaxContexts should not be nested at all but if they are, they cannot have different versions. Stick with one version of MathJax in your app and avoid using more than one MathJaxContext.");if(2===n&&void 0!==r||3===n&&void 0!==i)throw Error("Cannot use MathJax versions 2 and 3 simultaneously in the same app due to how MathJax is set up in the browser; either you have multiple MathJaxContexts with different versions or you have mounted and unmounted MathJaxContexts with different versions. Please stick with one version of MathJax in your app. File an issue in the project Github page if you need this feature.");var w=(0,o.useRef)(v),v=(0,o.useRef)((null==v?void 0:v.version)||null);if(null===v.current)v.current=n;else if(v.current!==n)throw Error("Cannot change version of MathJax in a MathJaxContext after it has mounted. Reload the page with a new version when this must happen.");var b=h||(2===n?l:c);function j(e,n){t&&(window.MathJax=t);var i=document.createElement("script");i.type="text/javascript",i.src=b,i.async=m,i.addEventListener("load",function(){var t=window.MathJax;d&&d(t),e(t),u&&u()}),i.addEventListener("error",function(e){return n(e)}),document.getElementsByTagName("head")[0].appendChild(i)}return void 0===w.current&&(v={typesettingOptions:f,renderMode:g,hideUntilTypeset:x},2===n?void 0===i&&("undefined"!=typeof window?(i=new Promise(j)).catch(function(e){if(!p)throw Error("Failed to download MathJax version 2 from '".concat(b,"' due to: ").concat(JSON.stringify(e)));p(e)}):(i=Promise.reject()).catch(function(e){})):void 0===r&&("undefined"!=typeof window?(r=new Promise(j)).catch(function(e){if(!p)throw Error("Failed to download MathJax version 3 from '".concat(b,"' due to: ").concat(e));p(e)}):(r=Promise.reject()).catch(function(e){})),w.current=a(a({},v),2===n?{version:2,promise:i}:{version:3,promise:r})),o.createElement(s.Provider,{value:w.current},e)}},5565:(e,t,n)=>{"use strict";n.d(t,{default:()=>r.a});var i=n(4146),r=n.n(i)},3018:e=>{!function(){"use strict";var t={114:function(e){function t(e){if("string"!=typeof e)throw TypeError("Path must be a string. Received "+JSON.stringify(e))}function n(e,t){for(var n,i="",r=0,o=-1,a=0,s=0;s<=e.length;++s){if(s<e.length)n=e.charCodeAt(s);else if(47===n)break;else n=47;if(47===n){if(o===s-1||1===a);else if(o!==s-1&&2===a){if(i.length<2||2!==r||46!==i.charCodeAt(i.length-1)||46!==i.charCodeAt(i.length-2)){if(i.length>2){var l=i.lastIndexOf("/");if(l!==i.length-1){-1===l?(i="",r=0):r=(i=i.slice(0,l)).length-1-i.lastIndexOf("/"),o=s,a=0;continue}}else if(2===i.length||1===i.length){i="",r=0,o=s,a=0;continue}}t&&(i.length>0?i+="/..":i="..",r=2)}else i.length>0?i+="/"+e.slice(o+1,s):i=e.slice(o+1,s),r=s-o-1;o=s,a=0}else 46===n&&-1!==a?++a:a=-1}return i}var i={resolve:function(){for(var e,i,r="",o=!1,a=arguments.length-1;a>=-1&&!o;a--)a>=0?i=arguments[a]:(void 0===e&&(e=""),i=e),t(i),0!==i.length&&(r=i+"/"+r,o=47===i.charCodeAt(0));return(r=n(r,!o),o)?r.length>0?"/"+r:"/":r.length>0?r:"."},normalize:function(e){if(t(e),0===e.length)return".";var i=47===e.charCodeAt(0),r=47===e.charCodeAt(e.length-1);return(0!==(e=n(e,!i)).length||i||(e="."),e.length>0&&r&&(e+="/"),i)?"/"+e:e},isAbsolute:function(e){return t(e),e.length>0&&47===e.charCodeAt(0)},join:function(){if(0==arguments.length)return".";for(var e,n=0;n<arguments.length;++n){var r=arguments[n];t(r),r.length>0&&(void 0===e?e=r:e+="/"+r)}return void 0===e?".":i.normalize(e)},relative:function(e,n){if(t(e),t(n),e===n||(e=i.resolve(e))===(n=i.resolve(n)))return"";for(var r=1;r<e.length&&47===e.charCodeAt(r);++r);for(var o=e.length,a=o-r,s=1;s<n.length&&47===n.charCodeAt(s);++s);for(var l=n.length-s,c=a<l?a:l,h=-1,d=0;d<=c;++d){if(d===c){if(l>c){if(47===n.charCodeAt(s+d))return n.slice(s+d+1);if(0===d)return n.slice(s+d)}else a>c&&(47===e.charCodeAt(r+d)?h=d:0===d&&(h=0));break}var u=e.charCodeAt(r+d);if(u!==n.charCodeAt(s+d))break;47===u&&(h=d)}var f="";for(d=r+h+1;d<=o;++d)(d===o||47===e.charCodeAt(d))&&(0===f.length?f+="..":f+="/..");return f.length>0?f+n.slice(s+h):(s+=h,47===n.charCodeAt(s)&&++s,n.slice(s))},_makeLong:function(e){return e},dirname:function(e){if(t(e),0===e.length)return".";for(var n=e.charCodeAt(0),i=47===n,r=-1,o=!0,a=e.length-1;a>=1;--a)if(47===(n=e.charCodeAt(a))){if(!o){r=a;break}}else o=!1;return -1===r?i?"/":".":i&&1===r?"//":e.slice(0,r)},basename:function(e,n){if(void 0!==n&&"string"!=typeof n)throw TypeError('"ext" argument must be a string');t(e);var i,r=0,o=-1,a=!0;if(void 0!==n&&n.length>0&&n.length<=e.length){if(n.length===e.length&&n===e)return"";var s=n.length-1,l=-1;for(i=e.length-1;i>=0;--i){var c=e.charCodeAt(i);if(47===c){if(!a){r=i+1;break}}else -1===l&&(a=!1,l=i+1),s>=0&&(c===n.charCodeAt(s)?-1==--s&&(o=i):(s=-1,o=l))}return r===o?o=l:-1===o&&(o=e.length),e.slice(r,o)}for(i=e.length-1;i>=0;--i)if(47===e.charCodeAt(i)){if(!a){r=i+1;break}}else -1===o&&(a=!1,o=i+1);return -1===o?"":e.slice(r,o)},extname:function(e){t(e);for(var n=-1,i=0,r=-1,o=!0,a=0,s=e.length-1;s>=0;--s){var l=e.charCodeAt(s);if(47===l){if(!o){i=s+1;break}continue}-1===r&&(o=!1,r=s+1),46===l?-1===n?n=s:1!==a&&(a=1):-1!==n&&(a=-1)}return -1===n||-1===r||0===a||1===a&&n===r-1&&n===i+1?"":e.slice(n,r)},format:function(e){var t,n;if(null===e||"object"!=typeof e)throw TypeError('The "pathObject" argument must be of type Object. Received type '+typeof e);return t=e.dir||e.root,n=e.base||(e.name||"")+(e.ext||""),t?t===e.root?t+n:t+"/"+n:n},parse:function(e){t(e);var n,i={root:"",dir:"",base:"",ext:"",name:""};if(0===e.length)return i;var r=e.charCodeAt(0),o=47===r;o?(i.root="/",n=1):n=0;for(var a=-1,s=0,l=-1,c=!0,h=e.length-1,d=0;h>=n;--h){if(47===(r=e.charCodeAt(h))){if(!c){s=h+1;break}continue}-1===l&&(c=!1,l=h+1),46===r?-1===a?a=h:1!==d&&(d=1):-1!==a&&(d=-1)}return -1===a||-1===l||0===d||1===d&&a===l-1&&a===s+1?-1!==l&&(0===s&&o?i.base=i.name=e.slice(1,l):i.base=i.name=e.slice(s,l)):(0===s&&o?(i.name=e.slice(1,a),i.base=e.slice(1,l)):(i.name=e.slice(s,a),i.base=e.slice(s,l)),i.ext=e.slice(a,l)),s>0?i.dir=e.slice(0,s-1):o&&(i.dir="/"),i},sep:"/",delimiter:":",win32:null,posix:null};i.posix=i,e.exports=i}},n={};function i(e){var r=n[e];if(void 0!==r)return r.exports;var o=n[e]={exports:{}},a=!0;try{t[e](o,o.exports,i),a=!1}finally{a&&delete n[e]}return o.exports}i.ab="//";var r=i(114);e.exports=r}()},4146:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),function(e,t){for(var n in t)Object.defineProperty(e,n,{enumerable:!0,get:t[n]})}(t,{default:function(){return l},getImageProps:function(){return s}});let i=n(306),r=n(666),o=n(7970),a=i._(n(5514));function s(e){let{props:t}=(0,r.getImgProps)(e,{defaultLoader:a.default,imgConf:{deviceSizes:[640,750,828,1080,1200,1920,2048,3840],imageSizes:[16,32,48,64,96,128,256,384],path:"/_next/image",loader:"default",dangerouslyAllowSVG:!1,unoptimized:!0}});for(let[e,n]of Object.entries(t))void 0===n&&delete t[e];return{props:t}}let l=o.Image},5624:(e,t,n)=>{"use strict";n.r(t),n.d(t,{default:()=>m});var i=n(5155),r=n(3018),o=n.n(r),a=n(8989),s=n(9727),l=n(2723),c=n(5565),h=n(9730),d=n(1109);let u=o().join("/projects/ComputerGraphics/Project3","media"),f=[{id:"Overview",content:(0,i.jsxs)("div",{children:[(0,i.jsx)("h2",{children:" Overview "}),(0,i.jsx)("p",{children:"In this project, I have implemented methods simulate light in a scene and have explored ways to speed this up using a bounding volume hierarchy. From completing this assignment, I got a better grasp of how light interacts with objects and how different materials are rendered."})]})},{id:"Ray Generation and Scene Intersection",content:(0,i.jsxs)("div",{children:[(0,i.jsx)("h2",{children:"Ray Generation and Scene Intersection "}),(0,i.jsxs)("p",{children:["To generate the camera rays for our scene, we normalize our image coordinates which we use to calculate the rays from the camera based on the vertical and horizontal field of views. The bottom left corner of the camera sensor is given by",(0,i.jsx)(h.A,{children:"\\begin{equation*} bl = \\left(-\\tan\\frac{hFov}{2}, -\\tan\\frac{vFov}{2} \\right) \\end{equation*}"}),"and for the top right, we get:",(0,i.jsx)(h.A,{children:"\\begin{equation*} tr = \\left(\\tan\\frac{hFov}{2}, \\tan\\frac{vFov}{2} \\right) \\end{equation*}"}),"So if we have a point ",(0,i.jsx)(h.A,{inline:!0,children:"\\(x, y\\)"})," ","on the image, it would be a linear interpolation between the bottom left point and top right:",(0,i.jsx)(h.A,{children:"\\begin{equation*}bl + (x(tr - bl)[0], y(tr - bl)[1]) \\end{equation*}"})]}),(0,i.jsxs)("p",{children:["Next would be intersection the ray with various objects in the scene. The first intersection test would be with a triangle, and the method I used included solving a system of equations for the barycentric coordinates of a potential intersection point. This is known as the Moller-Trumbore algorithm, and we can recover the coefficients by solving the system:",(0,i.jsx)(h.A,{children:"\\begin{equation*}\\begin{bmatrix}\\mid & \\mid & \\mid \\\\-D & (p_{2}-p_{1}) & (p_{3}-p_{1}) \\\\ \\mid & \\mid & \\mid \\end{bmatrix}\\begin{bmatrix} t \\\\ u \\\\ v \\end{bmatrix} = r.o - p_{1} \\end{equation*}"}),"From this system, we get"," ",(0,i.jsx)(h.A,{inline:!0,children:"\\(t, u, v\\)"}),", and for the last barycentric value, we can take"," ",(0,i.jsx)(h.A,{inline:!0,children:"\\(1 - u - v\\)"}),". To check that the ray intersects the object, we require that"," ",(0,i.jsx)(h.A,{inline:!0,children:"\\(t >= 0\\)"})," and that there were no objects closer to the ray that the ray has already intersected with. So we also need"," ",(0,i.jsx)(h.A,{inline:!0,children:"\\(t <= r.max_t\\)"}),"."]}),(0,i.jsxs)(l.V,{columns:2,children:[(0,i.jsx)(c.default,{src:o().join(u,"part1/CBempty.png"),width:800,height:600,alt:"Triangle ray intersection render"}),(0,i.jsx)(c.default,{src:o().join(u,"part1/CBcoil.png"),width:800,height:600,alt:"Coil render"})]}),(0,i.jsxs)("p",{children:["We can also calculate the intersection of rays with sphere since we have the formula for both. The formula for a sphere is:",(0,i.jsx)(h.A,{children:"\\begin{equation*}\\lVert v - s.c \\rVert = s.r\\end{equation*}"}),"And for a ray:",(0,i.jsx)(h.A,{children:"\\begin{equation*} v = r.o + r.d \\cdot t \\end{equation*}"}),"Then substituting in ",(0,i.jsx)(h.A,{inline:!0,children:"\\(v\\)"})," into the sphere equation, we get a quadratic equation and can solve for"," ",(0,i.jsx)(h.A,{inline:!0,children:"\\(t\\)"})," with the quadratic formula:",(0,i.jsx)(h.A,{inline:!0,children:"\\begin{align*} a &= dot(r.d, r.d)                       \\\\ b &= 2 * dot(s.c - r.o, r.d)             \\\\ c &= dot(s.c - r.o, s.c - r.o) - s.r^{2}   \\end{align*} "}),"We check for a nonnegative determinant to get solutions and here is the result of the ray intersection with a sphere:",(0,i.jsx)(l.V,{className:"max-w-[30rem]",children:(0,i.jsx)(c.default,{src:o().join(u,"part1/CBspheres.png"),width:800,height:600,alt:"Sphere ray intersection render"})})]})]})},{id:"Bounding Volume Hierarchy",content:(0,i.jsxs)("div",{children:[(0,i.jsx)("h2",{children:" Bounding Volume Hierarchy "}),(0,i.jsx)("p",{children:"In a bvh, we store objects and their bounding boxes. When we construct our tree out of these bounding boxes, we split the bounding boxes into a left and right set and call our constructor on the left and right set. We continue dividing the bounding boxes until there are less than max_children objects in the current set. A bvh allows us to efficiently prune off objects in the tree that we know do not intersect with our ray when we start raytracing."}),(0,i.jsxs)("p",{children:["The split method I used was computing the averages of the centroids of each bounding box. I then iterate over each dimension computing the splits in each. So for dimensions"," ",(0,i.jsx)(h.A,{inline:!0,children:"\\(x, y, z\\)"}),", I would get sets"," ",(0,i.jsx)(h.A,{inline:!0,children:"\\(l, r\\)"}),". Then the cost given to the split is:",(0,i.jsx)(h.A,{children:"\\begin{equation*}\\text{SA}(l) \\cdot \\text{l.size}() + \\text{SA}(r) \\cdot \\text{r.size}()\\end{equation*}"}),"The dimension that gives the lowest cost is chosen. At a high level, this computes the cost of raytracing, as the probability of a ray hitting a box is proportional to the box's surface area, and the cost of traversal is equal to the number of items in the box."]}),(0,i.jsx)("p",{children:"The objects in the bvh were stored in a flat array, and the current objects in our node are represented by a start and end pointer to a continuous segement. So to split, we sort this array similar to inplace quicksorting, then recurse given a left, right partition."}),(0,i.jsx)("p",{children:"Finally, here are some renders of scenes with a large number of objects:"}),(0,i.jsx)(l.V,{columns:3,children:["blob","blucy","dragon"].map((e,t)=>{let n=o().join(u,"part2/".concat(e,".png"));return(0,i.jsxs)(l.D,{children:[(0,i.jsx)(c.default,{className:"zoom-in",src:n,alt:"".concat(e," default shading with bounding volume hierarchy"),width:800,height:600}),(0,i.jsxs)("figcaption",{children:[" ",e,", bvh, default shading "]})]},t)})})]})},{id:"Direct Illumination",content:(0,i.jsxs)("div",{children:[(0,i.jsx)("h2",{children:" Direct Illumination "}),(0,i.jsx)("p",{children:"Direct Illumination refers to the incoming light onto a surface from a light source without indirect bounces. When calculating the illumination an object recieves, we consider the angle of the incoming ray, the bsdf function that describes the surface (ratio/distribution of incoming light to outgoing light), and finally, the actual luminous power and color the ray carries."}),(0,i.jsx)("h3",{children:" Zero-bounce Illumination "}),(0,i.jsx)("p",{children:"In zero-bounce illumination, from a given ray w_in, we would compute the intersection of that ray with our scene. The object that it intersects with gives an emission, which is what I returned from the function."}),(0,i.jsx)("h3",{children:" Direct Lighting with Uniform Hemisphere Sampling"}),(0,i.jsxs)("p",{children:["To implement uniform hemisphere sampling for lighting, I sampled for vectors in the hemisphere of the origin point of the ray. Then for each sample, I compute the ray's intersection with the scene, and we can get the illumination by:",(0,i.jsx)(h.A,{children:"\\begin{equation*}\\text{isect.bsdf}\\rightarrow\\text{get_emission()} \\cdot \\text{cos_theta(w_in)} \\cdot \\text{bsdf}\\rightarrow\\text{f(w_out, w_in)}\\end{equation*}"}),"Here are some examples:"]}),(0,i.jsx)(l.V,{columns:3,children:["bunny","coil","dragon"].map((e,t)=>{let n=o().join(u,"part3/uniform/".concat(e,"_64_32.png"));return(0,i.jsxs)(l.D,{children:[(0,i.jsx)(c.default,{className:"zoom-in",src:n,alt:"".concat(e,", uniform sampling"),width:800,height:600}),(0,i.jsxs)("figcaption",{children:[" ",e," "]})]},t)})}),(0,i.jsx)("h3",{children:" Direct Lighting by Importance Sampling Lights "}),(0,i.jsxs)("p",{children:["For importance sampling, we iterate over each light and sample from it"," ",(0,i.jsx)(h.A,{inline:!0,children:"\\(n\\)"})," times. After sampling from the light, we set the ray's ",(0,i.jsx)("code",{children:"min_t"})," to"," ",(0,i.jsx)("code",{children:"EPS_F"})," and ",(0,i.jsx)("code",{children:" max_t"})," to"," ",(0,i.jsx)("code",{children:"distToLight - EPS_F"})," to check if there are any scene objects between the light and surface that would block the light. If not, we compute the illumination similar to above and take the average out of those ",(0,i.jsx)(h.A,{inline:!0,children:"\\(n\\)"})," samples. Since we do not sample uniformly, we need to divide our sample by the probability of making that sample. Finally, summing the illumination over all light sources gives us the lighting from importance sampling."]}),(0,i.jsx)(l.V,{columns:3,children:["bunny","coil","dragon"].map((e,t)=>{let n=o().join(u,"part3/importance/".concat(e,"_64_32.png"));return(0,i.jsxs)(l.D,{children:[(0,i.jsx)(c.default,{className:"zoom-in",src:n,alt:"".concat(e,", importance sampling"),width:800,height:600}),(0,i.jsxs)("figcaption",{children:[" ",e," "]})]},t)})}),(0,i.jsx)("p",{children:"Here is an example of increasing the amount of samples we draw from each light source:"}),(0,i.jsx)(l.V,{columns:2,children:[1,4,16,64].map(e=>{let t=o().join(u,"part3/l_samples/coil_1_".concat(e,".png"));return(0,i.jsxs)(l.D,{children:[(0,i.jsx)(c.default,{src:t,alt:"Coil with ".concat(e," light samples"),width:800,height:600}),(0,i.jsxs)("figcaption",{children:[" Coil, light ",e," "]})]},e)})}),(0,i.jsx)("p",{children:"A difference between uniform sampling and importance sampling would be the amount of noise in the image. With importance sampling, we sample directly from the light source, which allows us to converge faster to the solution. From the images above, the ones obtained from uniform sampling are grainier, with much more variation in the color on each wall compared to importance sampling."})]})},{id:"Global Illumination",content:(0,i.jsxs)("div",{children:[(0,i.jsx)("h2",{children:" Global Illumination "}),(0,i.jsx)("p",{children:"For indirect lighting, we would use a recursive function and trace a ray to a surface. If the ray's depth was 1, we would just return the one bounce illumination from the previous part. Otherwise, we sample a ray on the hemisphere, translated to world coordinates, recurse using the function. Since the function returns incoming light, we would multiply by the bsdf and cos_theta for the angle, giving the illumination of the surface."}),(0,i.jsx)("p",{children:"This is the illumination where we do not accumulate the illumination from previous bounces:"}),(0,i.jsx)(l.V,{columns:3,children:[0,1,2,3,4,5].map(e=>{let t=o().join(u,"part4/bunnyNAcc/bunny-M".concat(e,"-NAcc.png"));return(0,i.jsxs)(l.D,{children:[(0,i.jsx)(c.default,{className:"zoom-in",src:t,alt:"Luminance with num_ray_bounces = ".concat(e),width:800,height:600}),(0,i.jsxs)("figcaption",{children:[" depth = ",e," "]})]},e)})}),(0,i.jsx)("p",{children:" And this is with isAccumBounces enabled:"}),(0,i.jsx)(l.V,{columns:3,children:[0,1,2,3,4,5].map(e=>{let t=o().join(u,"part4/bunnyAcc/bunny-M".concat(e,"-Acc.png"));return(0,i.jsxs)(l.D,{children:[(0,i.jsx)(c.default,{className:"zoom-in",src:t,alt:"Accumulated bounces with max_ray_depth = ".concat(e),width:800,height:600}),(0,i.jsxs)("figcaption",{children:[" m_depth = ",e," "]})]},e)})}),(0,i.jsx)("p",{children:"When the light is not accumulated, with more bounces, it loses brightness, and this makes sense because the light is scattered when it comes in contact with a surface. When the light is accumulated, the scene becomes brighter, because many areas are more likely to come in contact with light rays when we allow for more bounces."}),(0,i.jsx)("p",{children:"We can also split the rendering into direct and indirect lighting. Something interesting to note is that with direct lighting, we get the base color of the object while indirect lighting captures more of the reflective properties of the object:"}),(0,i.jsx)(l.V,{columns:3,children:["original","direct","indirect"].map(e=>{let t=o().join(u,"part4/dragon/dragon-".concat(e,".png"));return(0,i.jsxs)(l.D,{children:[(0,i.jsx)(c.default,{className:"zoom-in",src:t,alt:"Dragon rendered with ".concat(e," lighting"),width:800,height:600}),(0,i.jsxs)("figcaption",{children:[" ",e," "]})]},e)})}),(0,i.jsx)("p",{children:"Finally, this shows spheres rendered with a varying number of samples-per-pixel:"}),(0,i.jsx)(l.V,{columns:4,children:[1,2,4,8,16,64,1024].map(e=>{let t=o().join(u,"part4/spheres/spheres-S".concat(e,".png"));return(0,i.jsxs)(l.D,{children:[(0,i.jsx)(c.default,{className:"zoom-in",src:t,alt:"Spheres rendered with ".concat(e," samples per pixel"),width:800,height:600}),(0,i.jsxs)("figcaption",{children:[" ",e," spp "]})]},e)})}),(0,i.jsx)("h2",{children:" Russian Roulette "}),(0,i.jsxs)("p",{children:["Computing the global illumination requires us to sum over all the"," ",(0,i.jsx)(h.A,{inline:!0,children:"\\(k\\)"}),"-bounces of light through a scene for ",(0,i.jsx)(h.A,{inline:!0,children:"\\(k \\geq 0\\)"}),". An unbiased solution to this problem involves flipping a coin with weight"," ",(0,i.jsx)(h.A,{inline:!0,children:"\\(cpdf\\)"})," to check whether the ray should continue bouncing. If it does, we calculate the incoming light and divide that additionally by the"," ",(0,i.jsx)(h.A,{inline:!0,children:"\\(cpdf\\)"}),". If not, we return the one bounce illumination function as the base case."]}),(0,i.jsx)(l.V,{columns:3,children:[0,1,2,3,4,100].map(e=>{let t=o().join(u,"part4/bunnyRR/bunny-M".concat(e,"-RR.png"));return(0,i.jsxs)(l.D,{children:[(0,i.jsx)(c.default,{className:"zoom-in",src:t,alt:"Russian roulette bunny scene with max_ray_depth = ".concat(e),width:800,height:600}),(0,i.jsxs)("figcaption",{children:[" m_depth = ",e," "]})]},e)})})]})},{id:"Adaptive Sampling",content:(0,i.jsxs)("div",{children:[(0,i.jsx)("h2",{children:"Adaptive Sampling"}),(0,i.jsxs)("p",{children:["In adaptive sampling, we check that the margin of error is less than a given tolerance. So given ",(0,i.jsx)(h.A,{inline:!0,children:"\\(n\\)"})," ","samples, I calculated the illumination of the sample, the average illumination and variance of illumination. Then"," ",(0,i.jsx)(h.A,{children:"\\begin{equation*}I = 1.96 \\cdot \\sqrt{\\frac{\\sigma^2}{n}}\\end{equation*}"}),"and I checked for every ",(0,i.jsx)(h.A,{inline:!0,children:"\\(32\\)"})," ","samples if"," ",(0,i.jsx)(h.A,{inline:!0,children:"\\(I \\leq maxTolerance \\cdot \\mu \\)"})," ","which would be the condition to stop. Here are some results:"]}),(0,i.jsx)(l.V,{columns:3,children:["bunny","coil","dragon"].map(e=>{let t=o().join(u,"part5/".concat(e,"-adp.png")),n=o().join(u,"part5/".concat(e,"-adp_rate.png"));return(0,i.jsxs)("div",{children:[(0,i.jsxs)(l.D,{children:[(0,i.jsx)(c.default,{className:"zoom-in",src:t,alt:"Adaptive sampling of ".concat(e),width:800,height:600}),(0,i.jsxs)("figcaption",{children:[" ",e," S=2048 M=5 "]})]}),(0,i.jsxs)(l.D,{children:[(0,i.jsx)(c.default,{className:"zoom-in",src:n,alt:"Adaptive sampling rate of ".concat(e),width:800,height:600}),(0,i.jsxs)("figcaption",{children:[" ",e," sampling rate "]})]})]},e)})}),(0,i.jsx)("p",{children:"With adaptive sampling, parts of the scene that are not directly visible to the light are sampled more. For instance, the shadow of the bunny and coil are red, while the walls are blue."})]})}];function m(){return(0,i.jsxs)("div",{children:[(0,i.jsxs)(a.l,{children:[(0,i.jsx)("h1",{children:"Project 3: Ray Tracing and Illumination"}),(0,i.jsx)("p",{children:"(https://trustinn.github.io/projects/ComputerGraphics/Project3)"})]}),(0,i.jsx)(s.LN,{children:(0,i.jsxs)(s.J3,{children:[(0,i.jsx)(s.nA,{children:f.map(e=>(0,i.jsx)(s.wn,{children:(0,i.jsx)(s.n9,{id:e.id,link:e.link,children:e.content})},e.id))}),(0,i.jsx)(d.B,{ids:f.map(e=>e.id)})]})})]})}},8989:(e,t,n)=>{"use strict";n.d(t,{l:()=>r});var i=n(5155);let r=e=>{let{children:t}=e;return(0,i.jsx)("div",{className:"text-center text-black p-20 row-span-2 row-start-1 row-end-2 flex flex-col flex-nowrap justify-center items-center w-full",children:t})}},9727:(e,t,n)=>{"use strict";n.d(t,{J3:()=>d,LN:()=>u,n9:()=>l,nA:()=>c,wn:()=>h});var i=n(5155),r=n(8173),o=n.n(r),a=n(9795);let s=(e,t)=>(0,i.jsx)(o(),{href:e,className:"z-10 block absolute top-0 ".concat(t?"":"max-w-[95%]"," w-full h-full bg-black rounded-2xl text-white ").concat(t?"hover:scale-x-105 hover:translate-x-[2%]  hover:translate-y-[4%]":"hover:translate-x-[2%]"," transform ease-in-out duration-200"),children:(0,i.jsx)("div",{className:"flex flex-row w-full h-full items-center justify-end ",children:(0,i.jsx)("div",{className:"w-[8%]",children:"➧"})})}),l=e=>{let{id:t,link:n,orientation:r,className:o,children:l}=e;return(0,i.jsxs)("div",{className:"h-fit",children:[(0,i.jsx)("article",{className:(0,a.QP)("relative z-50 m-0 p-8 text-left ".concat(r?"max-h-[90%] w-full":"max-w-[85%] h-full"," ").concat(n?"":"max-w-[100%]"," h-fit rounded-2xl bg-white text-black ").concat(o)),id:t,children:l}),n?s(n,r):""]})},c=e=>{let{children:t}=e;return(0,i.jsx)("div",{className:"flex flex-col flex-grow max-w-[60rem]",children:t})},h=e=>{let{children:t,className:n}=e;return(0,i.jsx)("section",{className:(0,a.QP)("mb-8 mx-[5vw] rounded-[1rem] shadow-[0px_5px_15px_rgba(0,0,0,0.35)] h-fit relative bg-red ".concat(n)),children:t})},d=e=>{let{children:t}=e;return(0,i.jsx)("div",{className:"flex flex-row flex-nowrap justify-center relative",children:t})},u=e=>{let{children:t}=e;return(0,i.jsx)("div",{className:"mx-[5vw]",children:t})}},2723:(e,t,n)=>{"use strict";n.d(t,{D:()=>a,V:()=>s});var i=n(5155),r=n(2115),o=n(9795);let a=e=>{let{children:t,className:n}=e;return(0,i.jsx)("figure",{className:"text-center ".concat(n),children:r.Children.map(t,e=>r.isValidElement(e)&&"string"!=typeof e.type?r.cloneElement(e,{className:(0,o.QP)(e.props.className,"w-full text-center")}):e)})},s=e=>{let{columns:t=1,className:n,children:a}=e;return(0,i.jsx)("div",{className:(0,o.QP)("grid ".concat(["grid-cols-0","grid-cols-1","grid-cols-2","grid-cols-3","grid-cols-4","grid-cols-5","grid-cols-6","grid-cols-7","grid-cols-8"][t]," gap-4 items-center justify-center w-full max-w-[90%] mx-auto py-4 ").concat(n," ")),children:r.Children.map(a,e=>r.isValidElement(e)&&"string"!=typeof e.type?r.cloneElement(e,{className:(0,o.QP)(e.props.className,"w-full")}):e)})}},1109:(e,t,n)=>{"use strict";n.d(t,{B:()=>r});var i=n(5155);let r=e=>{let{ids:t,children:n}=e;return(0,i.jsx)("div",{className:"block flex-grow max-w-[25%]",children:(0,i.jsxs)("div",{className:"max-w-[80%] mx-auto h-full",children:[n,t?(0,i.jsx)("div",{className:"sticky top-[20%] p-4 pl-6 border-1 border-black border-solid rounded-[1rem] bg-black shadow-[0px_5px_15px_rgba(0,0,0,0.35)] h-auto  max-h-[60vh] overflow-y-auto ",children:(0,i.jsx)("nav",{children:t.map(e=>(0,i.jsx)("ul",{children:(0,i.jsx)("a",{className:"block scale-90 hover:text-slate-300 transition-transform  duration-100 ease-in-out text-[1.1rem] hover:scale-100 focus:scale-100 ",href:"#".concat(e),children:e})},e))})}):(0,i.jsx)("div",{})]})})}}},e=>{var t=t=>e(e.s=t);e.O(0,[173,795,970,441,517,358],()=>t(5081)),_N_E=e.O()}]);